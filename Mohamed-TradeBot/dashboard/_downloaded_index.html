<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TradeBot Dashboard - DynamoDB Table View (v1)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header>
    <h1>TradeBot Dashboard (v1)</h1>
    <p>Live view of the DynamoDB table</p>
  </header>
  <main>
    <section id="controls">
      <button id="refresh-btn">Refresh</button>
      <div class="filter-row">
        <label for="search">Filter: </label>
        <input id="search" class="search-input" placeholder="Type to filter rows..." />
      </div>
    </section>
    <section id="table">
      <div class="table-container">
      <table id="items-table">
        <thead id="thead"><tr></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
      </div>
    </section>
  </main>
  <footer>
    <p>Generated by TradeBot dashboard v1</p>
  </footer>

<script>
// Minimal dashboard: always read data.json (read-only)
async function fetchTable() {
  const res = await fetch('data.json', { cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to fetch data.json: ' + res.status);
  return await res.json();
}

function renderTable(items) {
  const thead = document.getElementById('thead').querySelector('tr');
  const tbody = document.getElementById('tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';
  if (!items || items.length === 0) {
    thead.innerHTML = '<th>No data</th>';
    return;
  }
  // Build union of columns across all items so analysis fields appear
  const colSet = new Set();
  items.forEach(it => Object.keys(it || {}).forEach(k => colSet.add(k)));
  const columns = Array.from(colSet);

  // Sort items descending by TradedDate then Timestamp (both ISO strings)
  items.sort((a, b) => {
    const ad = a.TradedDate || '';
    const bd = b.TradedDate || '';
    if (ad !== bd) return bd.localeCompare(ad); // descending by date
    const at = a.Timestamp || '';
    const bt = b.Timestamp || '';
    return bt.localeCompare(at); // descending by timestamp
  });
  for (const col of columns) {
    const th = document.createElement('th');
    th.textContent = col;
    thead.appendChild(th);
  }
  for (const item of items) {
    const tr = document.createElement('tr');
    for (const col of columns) {
      const td = document.createElement('td');
      const v = item[col];
      if (v === undefined || v === null) td.textContent = '';
      else if (typeof v === 'object') td.textContent = JSON.stringify(v);
      else td.textContent = String(v);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }
}

document.getElementById('refresh-btn').addEventListener('click', async () => {
  try {
    const data = await fetchTable();
    renderTable(data);
  } catch (err) {
    alert('Error: ' + err.message);
  }
});

// Load on start
// Sorting and filtering utilities
function sortByColumn(colIndex, asc) {
  const tbody = document.getElementById('tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  rows.sort((a, b) => {
    const ac = a.children[colIndex].textContent.trim();
    const bc = b.children[colIndex].textContent.trim();
    // try numeric compare
    const an = parseFloat(ac.replace(/[^0-9.-]+/g, ''));
    const bn = parseFloat(bc.replace(/[^0-9.-]+/g, ''));
    if (!isNaN(an) && !isNaN(bn)) return asc ? an - bn : bn - an;
    return asc ? ac.localeCompare(bc) : bc.localeCompare(ac);
  });
  tbody.innerHTML = '';
  rows.forEach(r => tbody.appendChild(r));
}

document.getElementById('search').addEventListener('input', (e) => {
  const q = e.target.value.toLowerCase();
  const tbody = document.getElementById('tbody');
  Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
    const text = tr.textContent.toLowerCase();
    tr.style.display = text.indexOf(q) === -1 ? 'none' : '';
  });
});

// Attach click handlers to headers for sorting (delegated once table is rendered)
function attachHeaderSorting() {
  const theadRow = document.getElementById('thead').querySelector('tr');
  const ths = Array.from(theadRow.querySelectorAll('th'));
  ths.forEach((th, idx) => {
    let asc = true;
    th.addEventListener('click', () => {
      sortByColumn(idx, asc);
      asc = !asc;
    });
  });
}

// Re-attach headers after rendering
const originalRender = renderTable;
renderTable = function(items) {
  originalRender(items);
  attachHeaderSorting();
}

fetchTable().then(renderTable).catch(()=>{});
</script>
</body>
</html>