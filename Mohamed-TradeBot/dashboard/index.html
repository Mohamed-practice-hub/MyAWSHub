<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TradeBot Dashboard - DynamoDB Table View (v1)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header>
    <h1>TradeBot Dashboard (v1)</h1>
    <p>Snapshot view of the DynamoDB table � refresh to load the latest snapshot</p>
  </header>
  <main>
    <section id="controls">
      <button id="refresh-btn">Refresh</button>
      <button id="export-csv-btn">Export CSV (filtered)</button>
  <a id="download-csv-link" class="button" href="/data.csv" download>Download latest CSV</a>
      <!-- Column visibility control -->
      <div id="column-controls" style="position:relative;">
        <button id="columns-btn" class="secondary">Columns ▾</button>
          <label style="margin-left:8px; font-size:0.9rem; vertical-align:middle;">
            <input type="checkbox" id="hide-analysis-toggle" style="margin-right:6px; vertical-align:middle;" />
            Hide analysis
          </label>
        <button id="reset-prefs" class="secondary" style="margin-left:8px;">Reset prefs</button>
        <div id="columns-dropdown" style="display:none; position:absolute; left:0; top:36px; background:#fff; border:1px solid #e6eef8; padding:8px; border-radius:6px; box-shadow:0 6px 18px rgba(15,23,42,0.08); z-index:50;">
          <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px;">
            <small style="color:var(--muted); flex:1">Toggle columns</small>
            <button id="col-select-all" class="secondary">Select all</button>
            <button id="col-select-none" class="secondary">Select none</button>
          </div>
          <div id="columns-list" style="margin-top:6px; max-height:240px; overflow:auto; min-width:200px"></div>
          <div style="border-top:1px solid #eef2f8; margin-top:8px; padding-top:8px; text-align:right;">
            <button id="col-reset" class="secondary">Reset</button>
          </div>
        </div>
      </div>
      <div id="snapshot-info" style="margin-left:16px; display:inline-block; vertical-align:middle;">
        <small>JSON: <span id="json-last-mod">-</span></small>
        &nbsp;|&nbsp;
        <small>CSV: <span id="csv-last-mod">-</span></small>
      </div>
      <div id="row-info" style="margin-left:16px; display:inline-block; vertical-align:middle;">
        <small>Rows: <span id="row-count">-</span></small>
      </div>
      <div id="loader" aria-hidden="true" style="margin-left:12px; display:inline-block; vertical-align:middle;">
        <span class="spinner" style="display:none" id="spinner">Loading…</span>
      </div>
      <div class="filter-row">
        <label for="search">Filter: </label>
        <input id="search" class="search-input" placeholder="Type to filter rows..." />
      </div>
    </section>
    <section id="table">
      <div class="table-container">
      <table id="items-table">
        <thead id="thead"><tr></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
      </div>
    </section>
  </main>
  <footer>
    <p>Generated by TradeBot dashboard v1</p>
  </footer>

<script>
// Global analysis column group and defaults (used across functions)
const ANALYSIS_COLS = ['MA20','MA50','MA200','MACD','MACDHist','MACDSignal','RSI14','ATR'];
const DEFAULT_HIDDEN = ['Timestamp', ...ANALYSIS_COLS];

// Ensure localStorage is seeded with defaults on first visit so UI reflects defaults immediately
window.addEventListener('DOMContentLoaded', () => {
  const stored = localStorage.getItem('hidden_columns');
  if (!stored) {
    localStorage.setItem('hidden_columns', JSON.stringify(DEFAULT_HIDDEN.slice()));
  }
  // initialize the Hide analysis checkbox state early so it shows correctly before rendering
  try {
    const aToggle = document.getElementById('hide-analysis-toggle');
    if (aToggle) {
      const hidden = JSON.parse(localStorage.getItem('hidden_columns') || '[]');
      aToggle.checked = ANALYSIS_COLS.every(c => hidden.includes(c));
    }
  } catch (e) { /* ignore */ }
  // Support a URL flag to reset prefs: ?reset_prefs=1
  try{
    const params = new URLSearchParams(window.location.search || '');
    if (params.get('reset_prefs') === '1') {
      localStorage.removeItem('hidden_columns');
      // reload without the flag
      const u = new URL(window.location.href);
      u.searchParams.delete('reset_prefs');
      window.location.replace(u.toString());
    }
  }catch(e){}
});

document.getElementById('reset-prefs').addEventListener('click', ()=>{
  if (!confirm('Reset column preferences to defaults?')) return;
  localStorage.removeItem('hidden_columns');
  location.reload();
});
let isRendering = false;
// Minimal dashboard: always read data.json (read-only)
async function fetchTable() {
  const res = await fetch('data.json', { cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to fetch data.json: ' + res.status);
  const lm = res.headers.get('last-modified');
  const items = await res.json();
  return { items, lastModified: lm };
}

// Fetch S3 HEAD-like information using a small GET with 'range' to avoid full download (can't HEAD from browser due to CORS)
async function fetchLastModified(key) {
  try {
    const res = await fetch(key, { method: 'GET', cache: 'no-store' });
    if (!res.ok) return null;
    const lm = res.headers.get('last-modified');
    return lm;
  } catch (e) {
    return null;
  }
}

function renderTable(items) {
  // Rebuild thead and tbody atomically and swap them into the DOM to avoid partial renders
  const container = document.querySelector('.table-container');
  if (container) container.style.visibility = 'hidden';

  // Build union of columns across all items so analysis fields appear
  const colSet = new Set();
  items.forEach(it => Object.keys(it || {}).forEach(k => colSet.add(k)));
  const allColumns = Array.from(colSet);

  // Desired column order (user requested)
  const desiredOrder = [
    'SymbolKey','TradedDate','Open','Low','High','Close','Volume',
    'MA20','MA50','MA200','MACD','MACDHist','MACDSignal','RSI14','ATR',
    'Confidence','Signal','Timestamp'
  ];
  // Build columns in desired order first, then append any extra columns present
  const columns = [];
  const seen = new Set();
  for (const c of desiredOrder) {
    if (allColumns.includes(c)) { columns.push(c); seen.add(c); }
  }
  for (const c of allColumns) if (!seen.has(c)) columns.push(c);

  // Sort items descending by TradedDate then Timestamp (both ISO strings)
  items.sort((a, b) => {
    const ad = a.TradedDate || '';
    const bd = b.TradedDate || '';
    if (ad !== bd) return bd.localeCompare(ad); // descending by date
    const at = a.Timestamp || '';
    const bt = b.Timestamp || '';
    return bt.localeCompare(at); // descending by timestamp
  });

  // Create new thead and tbody off-DOM
  const newThead = document.createElement('thead');
  const headRow = document.createElement('tr');
  newThead.appendChild(headRow);
  // Suggested per-column min-widths (px). Adjust as needed for legibility.
  const widthMap = {
    'SymbolKey': 160, 'TradedDate': 110, 'Timestamp': 180,
    'Open': 90, 'Low': 90, 'High': 90, 'Close': 90, 'Volume': 110,
    'MA20': 90, 'MA50': 90, 'MA200': 100, 'MACD': 110, 'MACDHist': 110, 'MACDSignal': 110,
    'RSI14': 90, 'ATR': 90, 'Confidence': 110, 'Signal': 100
  };
  for (const col of columns) {
    const th = document.createElement('th');
    th.textContent = col;
    th.dataset.col = col;
    // Apply suggested min-width for consistent column sizing
    try{
      const w = widthMap[col] || 120;
      th.style.minWidth = w + 'px';
      th.style.boxSizing = 'border-box';
    }catch(e){}
    headRow.appendChild(th);
  }

  const newTbody = document.createElement('tbody');
  for (const item of items) {
    const tr = document.createElement('tr');
    for (const col of columns) {
      const td = document.createElement('td');
      td.dataset.col = col;
      const v = item[col];
      if (v === undefined || v === null) td.textContent = '';
      else if (typeof v === 'object') td.textContent = JSON.stringify(v);
      else td.textContent = String(v);
      // Add value-based classes for signals, confidence and analysis columns
      try{
        if (col === 'Signal'){
          const s = String(v || '').toUpperCase();
          if (s.includes('BUY')) td.classList.add('signal-buy');
          else if (s.includes('SELL')) td.classList.add('signal-sell');
          else td.classList.add('signal-hold');
        } else if (col === 'Confidence'){
          const c = String(v || '').toLowerCase();
          if (c.includes('high')) td.classList.add('confidence-high');
          else if (c.includes('med') || c.includes('medium')) td.classList.add('confidence-medium');
          else if (c.includes('low')) td.classList.add('confidence-low');
        } else if (ANALYSIS_COLS.includes(col)){
          td.classList.add('analysis-col');
          // try numeric coloring: positive/negative/zero
          const num = parseFloat(String(v).replace(/,/g, ''));
          if (!isNaN(num)){
            if (num > 0) td.classList.add('analysis-positive');
            else if (num < 0) td.classList.add('analysis-negative');
            else td.classList.add('analysis-zero');
          }
        }
      }catch(e){}
      tr.appendChild(td);
    }
    newTbody.appendChild(tr);
  }

  // Insert new thead then tbody into the table in correct order (clear first to be safe)
  const table = document.getElementById('items-table');
  // remove all children of table then append in order
  while (table.firstChild) table.removeChild(table.firstChild);
  table.appendChild(newThead);
  newThead.id = 'thead';
  table.appendChild(newTbody);
  newTbody.id = 'tbody';

  // update row count
  document.getElementById('row-count').textContent = items.length;
  // Build column toggles (checkboxes)
  buildColumnToggles(columns);
  // restore visibility and adjust header
  if (container) container.style.visibility = '';
  // ensure sticky header offset is correct after swap
  setTimeout(adjustStickyHeader, 10);
  // (diagnostics removed)
}

function buildColumnToggles(columns){
  const list = document.getElementById('columns-list');
  list.innerHTML = '';
  // default: if user has no saved preference, hide Timestamp and analysis columns by default
  const stored = localStorage.getItem('hidden_columns');
  const analysisCols = ['MA20','MA50','MA200','MACD','MACDHist','MACDSignal','RSI14','ATR'];
  const defaultHidden = ['Timestamp', ...analysisCols];
  const hidden = stored ? JSON.parse(stored) : defaultHidden.slice();
  // Create all checkboxes first
  const checkboxes = [];
  columns.forEach((col, idx) => {
    const id = 'colchk-' + idx;
    const div = document.createElement('div');
    div.style.marginBottom = '6px';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.id = id;
    cb.dataset.col = col;
    cb.checked = !hidden.includes(col);
    const lbl = document.createElement('label');
    lbl.htmlFor = id;
    lbl.textContent = ' ' + col;
    div.appendChild(cb);
    div.appendChild(lbl);
    list.appendChild(div);
    checkboxes.push(cb);
  });

  // Attach listeners and apply visibility in a single pass to avoid interleaved DOM reflows
  checkboxes.forEach(cb => {
    const col = cb.dataset.col;
    cb.addEventListener('change', () => {
      toggleColumn(col, cb.checked);
      // persist hidden list
      const curHidden = JSON.parse(localStorage.getItem('hidden_columns') || '[]');
      const newHidden = cb.checked ? curHidden.filter(x=>x!==col) : Array.from(new Set([...curHidden, col]));
      localStorage.setItem('hidden_columns', JSON.stringify(newHidden));
      // reflect in analysis toggle state
      const analysisHiddenNow = analysisCols.every(c => newHidden.includes(c));
      const aToggle = document.getElementById('hide-analysis-toggle');
      if (aToggle) aToggle.checked = analysisHiddenNow;
      // Update cloned header to reflect visibility changes
      try{ buildClonedHeader(); }catch(e){}
    });
    // apply initial visibility
    toggleColumn(col, cb.checked);
  });

  // Set analysis toggle checked state if all analysis columns are hidden
  try{
    const aToggle = document.getElementById('hide-analysis-toggle');
    if (aToggle){
      const analysisHidden = analysisCols.every(c => hidden.includes(c));
      aToggle.checked = analysisHidden;
    }
  }catch(e){}
}

// cloned header removed: simpler stable baseline without fixed cloned header


// Handle the single "Hide analysis" toggle which hides/shows a group of columns
document.getElementById('hide-analysis-toggle').addEventListener('change', (e) => {
  const hide = e.target.checked; // checked => hide analysis
  const analysisCols = ['MA20','MA50','MA200','MACD','MACDHist','MACDSignal','RSI14','ATR'];
  const curHidden = JSON.parse(localStorage.getItem('hidden_columns') || '[]');
  let newHidden = Array.from(curHidden);
  if (hide) {
    // add each analysis col to hidden
    for (const c of analysisCols) if (!newHidden.includes(c)) newHidden.push(c);
  } else {
    // remove them
    newHidden = newHidden.filter(x => !analysisCols.includes(x));
  }
  localStorage.setItem('hidden_columns', JSON.stringify(newHidden));
  // Update dropdown checkboxes and column visibility
  const list = document.getElementById('columns-list');
  Array.from(list.querySelectorAll('input[type=checkbox]')).forEach(cb => {
    const col = cb.dataset.col;
    if (analysisCols.includes(col)){
      const shouldShow = !newHidden.includes(col);
      if (cb.checked !== shouldShow){ cb.checked = shouldShow; cb.dispatchEvent(new Event('change')); }
    }
  });
});

function toggleColumn(colName, show){
  // header cells
  const thead = document.getElementById('thead').querySelector('tr');
  Array.from(thead.children).forEach(th => {
    if (th.dataset.col === colName){ th.style.display = show ? '' : 'none'; }
  });
  // body cells
  const tbody = document.getElementById('tbody');
  Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
    Array.from(tr.children).forEach(td => {
      if (td.dataset.col === colName){ td.style.display = show ? '' : 'none'; }
    });
  });
}

// Column dropdown toggle
document.getElementById('columns-btn').addEventListener('click', (e)=>{
  const dd = document.getElementById('columns-dropdown');
  dd.style.display = dd.style.display === 'none' ? 'block' : 'none';
});

// Close dropdown when clicking outside
document.addEventListener('click', (e)=>{
  const container = document.getElementById('column-controls');
  if (!container.contains(e.target)){
    document.getElementById('columns-dropdown').style.display = 'none';
  }
});

// Select all / none / reset helpers
document.getElementById('col-select-all').addEventListener('click', ()=>{
  const list = document.getElementById('columns-list');
  Array.from(list.querySelectorAll('input[type=checkbox]')).forEach(cb=>{ if(!cb.checked){ cb.checked=true; cb.dispatchEvent(new Event('change')); }});
});
document.getElementById('col-select-none').addEventListener('click', ()=>{
  const list = document.getElementById('columns-list');
  Array.from(list.querySelectorAll('input[type=checkbox]')).forEach(cb=>{ if(cb.checked){ cb.checked=false; cb.dispatchEvent(new Event('change')); }});
});
document.getElementById('col-reset').addEventListener('click', ()=>{
  localStorage.removeItem('hidden_columns');
  // rebuild toggles based on current columns
  const cols = Array.from(document.querySelectorAll('#thead tr th')).map(th=>th.dataset.col).filter(Boolean);
  buildColumnToggles(cols);
});

// Fix sticky header overlap by setting th top to header height
function adjustStickyHeader(){
  // Sticky header disabled to avoid layout issues; this function is a no-op.
}

window.addEventListener('resize', adjustStickyHeader);
// call after initial render
setTimeout(adjustStickyHeader, 200);

document.getElementById('refresh-btn').addEventListener('click', async () => {
  if (isRendering) return; // prevent concurrent refreshes
  isRendering = true;
  const spinner = document.getElementById('spinner');
  spinner.style.display = 'inline';
  document.getElementById('refresh-btn').disabled = true;
  try {
  const res = await fetchTable();
    // res: { items, lastModified }
    renderTable(res.items);
    // update last-modified indicators and download link
    const jsonLm = res.lastModified || await fetchLastModified('data.json');
    // Often JSON and CSV are updated together; fallback csv to same value
    const csvLmRemote = await fetchLastModified('data.csv');
    const csvLm = csvLmRemote || jsonLm;
    if (jsonLm) document.getElementById('json-last-mod').textContent = new Date(jsonLm).toLocaleString();
    if (csvLm) document.getElementById('csv-last-mod').textContent = new Date(csvLm).toLocaleString();
    // set download link with cache-busting timestamp
    const dl = document.getElementById('download-csv-link');
    const ts = Date.now();
    dl.href = `/data.csv?ts=${ts}`;
    // adjust sticky header after new content
    adjustStickyHeader();
  } catch (err) {
    alert('Error: ' + err.message);
  } finally {
    isRendering = false;
    spinner.style.display = 'none';
    document.getElementById('refresh-btn').disabled = false;
  }
});

// Export currently visible rows to CSV (respects the search filter / hidden rows)
function exportVisibleTableToCSV(filename = 'tradebot-data.csv') {
  const thead = document.getElementById('thead').querySelector('tr');
  const tbody = document.getElementById('tbody');
  const headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim());

  const rows = [];
  Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
    if (tr.style.display === 'none') return; // skip filtered-out rows
    const cells = Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim());
    rows.push(cells);
  });

  if (rows.length === 0) {
    alert('No rows visible to export');
    return;
  }

  // Build CSV content
  const escapeCell = (s) => {
    if (s == null) return '';
    // escape double quotes
    const str = String(s).replace(/"/g, '""');
    return '"' + str + '"';
  };

  const csvLines = [];
  csvLines.push(headers.map(escapeCell).join(','));
  for (const r of rows) csvLines.push(r.map(escapeCell).join(','));

  const csvContent = '\uFEFF' + csvLines.join('\n'); // prepend BOM for Excel
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

document.getElementById('export-csv-btn').addEventListener('click', () => exportVisibleTableToCSV());

// Load on start
// Sorting and filtering utilities
function sortByColumn(colIndex, asc) {
  const tbody = document.getElementById('tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  rows.sort((a, b) => {
    const ac = a.children[colIndex].textContent.trim();
    const bc = b.children[colIndex].textContent.trim();
    // try numeric compare
    const an = parseFloat(ac.replace(/[^0-9.-]+/g, ''));
    const bn = parseFloat(bc.replace(/[^0-9.-]+/g, ''));
    if (!isNaN(an) && !isNaN(bn)) return asc ? an - bn : bn - an;
    return asc ? ac.localeCompare(bc) : bc.localeCompare(ac);
  });
  tbody.innerHTML = '';
  rows.forEach(r => tbody.appendChild(r));
}

document.getElementById('search').addEventListener('input', (e) => {
  const q = e.target.value.toLowerCase();
  const tbody = document.getElementById('tbody');
  Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
    const text = tr.textContent.toLowerCase();
    tr.style.display = text.indexOf(q) === -1 ? 'none' : '';
  });
});

// Attach click handlers to headers for sorting (delegated once table is rendered)
function attachHeaderSorting() {
  const theadRow = document.getElementById('thead').querySelector('tr');
  const ths = Array.from(theadRow.querySelectorAll('th'));
  ths.forEach((th, idx) => {
    let asc = true;
    th.addEventListener('click', () => {
      sortByColumn(idx, asc);
      asc = !asc;
    });
  });
}

// Re-attach headers after rendering
const originalRender = renderTable;
renderTable = function(items) {
  originalRender(items);
  attachHeaderSorting();
}

// Trigger the same refresh flow on load so last-modified and CSV link are set
window.addEventListener('load', () => {
  const btn = document.getElementById('refresh-btn');
  if (btn) btn.click();
});
</script>
</body>
</html>
